<?php

/**
 * @file
 * Base module for the Organic Groups Sites functionality.
 */

// Variable names to store the Site enabled group types.
define('OG_SM_VARIABLE_GROUP_TYPES', 'og_sm_node_types');

// Permission to get access to Site administration.
define('OG_SM_PERMISSION_SITE_ADMIN', 'administer site');

/**
 * Implements hook_hook_info().
 */
function og_sm_hook_info() {
  $group = array('group' => 'og_sm');

  $hooks = array(
    'og_sm_site_type_add' => $group,
    'og_sm_site_type_remove' => $group,
    'og_sm_site_view' => $group,
    'og_sm_site_presave' => $group,
    'og_sm_site_prepare' => $group,
    'og_sm_site_insert' => $group,
    'og_sm_site_update' => $group,
    'og_sm_site_delete' => $group,
    'og_sm_site_cache_clear_all' => $group,
    'og_sm_site_homepage_alter' => $group,
    'og_sm_platform_administration_page_alter' => $group,
  );

  return $hooks;
}

/**
 * Implements hook_og_permission().
 */
function og_sm_og_permission() {
  return array(
    OG_SM_PERMISSION_SITE_ADMIN => array(
      'title' => t('Administer Site'),
      'description' => t('View the Site administration pages.'),
      'roles' => array(OG_AUTHENTICATED_ROLE),
      'default role' => array(OG_ADMINISTRATOR_ROLE),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function og_sm_menu() {
  $items = array();

  $file = 'og_sm.admin.inc';

  // Redirects to node/%nid/edit.
  $items['group/%/%og_sm_site/admin/site-edit'] = array(
    'title' => 'Edit Site',
    'type' => MENU_CALLBACK,
    'page callback' => 'og_sm_admin_site_edit',
    'page arguments' => array(2),
    'access callback' => 'node_access',
    'access arguments' => array('update', 2),
    'file' => $file,
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds setting to indicate a content type as being a Site type.
 * Uses hook_form_alter() as we want to add our settings to the OG part of the
 * node form and OG is only available trough hook_form_alter().
 */
function og_sm_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  // Get the default is Site state of the node_type.
  $node_type = isset($form['#node_type']->type)
    ? $form['#node_type']->type
    : NULL;
  $enabled = ($node_type && og_sm_is_site_type($node_type));

  $description = array(
    t('Make this content type a Site type.'),
    t('All nodes of this type will be recognized as being a Site.'),
    '<p><strong>' . t('WARNING: The content type needs also to be a Group type!') . '</strong></p>',
  );

  $form['og_sm'] = array(
    '#type' => 'fieldset',
    '#title' => t('Site Manager'),
    '#collapsible' => TRUE,
    '#group' => 'additional_settings',
  );
  $form['og_sm']['og_sm_node_type'] = array(
    '#title' => t('Site type'),
    '#type' => 'checkbox',
    '#return_value' => 1,
    '#default_value' => (int) $enabled,
    '#element_validate' => array('og_sm_node_type_form_field_validate'),
    '#description' => implode(PHP_EOL, $description),
  );
  $form['#submit'][] = 'og_sm_node_type_form_field_submit';
}

/**
 * Validation of the posted og_sm_node_type field value.
 *
 * This will check if the node type is also a group type.
 */
function og_sm_node_type_form_field_validate($element, &$form_state, $form) {
  $values = $form_state['values'];

  if ((bool) $values['og_sm_node_type'] && !(bool) $values['og_group_type']) {
    form_set_error(
      'og_sm_node_type',
      t('A content type can only be a Site if it also a Group type.')
    );
  }

  $form_state['og_sm_node_type'] = (bool) $values['og_sm_node_type'];
  unset($form_state['values']['og_sm_node_type']);
}

/**
 * Store or remove the node type into the Site content types.
 */
function og_sm_node_type_form_field_submit($form, $form_state) {
  $type = $form_state['values']['type'];
  if ((bool) $form_state['og_sm_node_type']) {
    og_sm_site_type_add($type);
  }
  else {
    og_sm_site_type_remove($type);
  }
}

/**
 * Load a Site node by its Node ID.
 *
 * This will only return a node object if:
 * - The node exists.
 * - The node is a Site node.
 *
 * @param int $site_nid
 *   The Site Node ID.
 *
 * @return object|false
 *   The Site Node (if any).
 */
function og_sm_site_load($site_nid) {
  $site = node_load($site_nid);
  if (!$site || !og_sm_is_site($site)) {
    return FALSE;
  }

  return $site;
}

/**
 * Clear all cache for one site.
 *
 * This function does not clear the cache itself, it calls all the implemented
 * hook_og_sm_site_cache_clear_all() hooks so modules can clear their specific
 * cached Site parts.
 *
 * @param object $site
 *   The Site to clear the cache for.
 */
function og_sm_site_cache_clear_all($site) {
  og_sm_hook_site('cache_clear_all', $site);
}

/**
 * Get an array of all Site Node ID's.
 *
 * WARNING: There is no node_access check on this function!
 *
 * @return array
 *   Array of all Site Node ID's.
 */
function og_sm_site_all_nids() {
  $site_types = og_sm_get_site_types();
  if (!$site_types) {
    return array();
  }

  $query = db_select('node', 'n');
  $query->addField('n', 'nid');
  $query->condition('n.type', $site_types);
  $query->orderBy('n.nid', 'ASC');

  return $query->execute()->fetchAllKeyed(0, 0);
}

/**
 * Check access to a OG permission for a Site.
 *
 * @param object $site
 *   The Site node.
 * @param string $permission
 *   The permission name.
 * @param object $account
 *   The optional account to check for.
 *
 * @return bool
 *   Has access.
 */
function og_sm_site_permission_access($site, $permission, $account = NULL) {
  return og_sm_site_nid_permission_access($site->nid, $permission, $account);
}

/**
 * Check access to a OG permission for a Site Node ID.
 *
 * @param int $site_nid
 *   The Site Node ID.
 * @param string $permission
 *   The permission name.
 * @param object $account
 *   The optional account to check for.
 *
 * @return bool
 *   Has access.
 */
function og_sm_site_nid_permission_access($site_nid, $permission, $account = NULL) {
  return og_user_access('node', $site_nid, $permission, $account);
}

/**
 * Get the currently active Site.
 *
 * @return object|null
 *   The active Site node (if any).
 */
function og_sm_current_site() {
  $context = og_context('node');
  if (!$context) {
    return FALSE;
  }

  return og_sm_site_load($context['gid']);
}

/**
 * Check if the given node is a Site type.
 *
 * @param object $site
 *   The site node.
 *
 * @return bool
 *   Is a Site node.
 */
function og_sm_is_site($site) {
  return og_sm_is_site_type($site->type);
}

/**
 * Get a list of Site node types.
 *
 * @return array
 *   List of node types that are Sites.
 */
function og_sm_get_site_types() {
  return variable_get(OG_SM_VARIABLE_GROUP_TYPES, array());
}

/**
 * Check if a given node type is a Site type.
 *
 * @param string $type
 *   The type to check.
 *
 * @return bool
 *   Is Site type.
 */
function og_sm_is_site_type($type) {
  $types = og_sm_get_site_types();
  return (og_is_group_type('node', $type) && in_array($type, $types));
}

/**
 * Add a type to the array of Site content types.
 *
 * @param string $type
 *   The content type to add.
 */
function og_sm_site_type_add($type) {
  $types = og_sm_get_site_types();

  if (!in_array($type, $types)) {
    $types[$type] = $type;
    variable_set(OG_SM_VARIABLE_GROUP_TYPES, $types);
    module_invoke_all('og_sm_site_type_add', $type);
  }
}

/**
 * Remove a type from the array of Site content types.
 *
 * @param string $type
 *   The content type to remove.
 */
function og_sm_site_type_remove($type) {
  $types = og_sm_get_site_types();

  if (in_array($type, $types)) {
    unset($types[$type]);
    variable_set(OG_SM_VARIABLE_GROUP_TYPES, $types);
    module_invoke_all('og_sm_site_type_remove', $type);
  }
}

/**
 * Get the platform administration page.
 *
 * @return string|false
 *   The path (not URL) to the Platform administration homepage.
 */
function og_sm_platform_administration_page() {
  // This can be called multiple times, lets add some static caching.
  $path = &drupal_static(__FUNCTION__, FALSE);
  if (!$path) {
    $path = 'admin';
    drupal_alter('og_sm_platform_administration_page', $path);
  }

  return $path;
}

/**
 * Get the homepage path for a Site.
 *
 * @param object $site
 *   The optional Site node. Will use the current Site from context if no Site
 *   is provided.
 *
 * @return string|false
 *   The path (not URL) to the Site homepage.
 */
function og_sm_site_homepage($site = NULL) {
  // Fallback to current Site.
  if (!$site) {
    $site = og_sm_current_site();
  }

  // Only if there is a Site.
  if (!$site || !og_sm_is_site($site)) {
    return FALSE;
  }

  // This can be called multiple times, lets add some static caching.
  $paths = &drupal_static(__FUNCTION__, array());
  if (!isset($paths[$site->nid])) {
    $path = 'node/' . $site->nid;
    $context = clone $site;
    drupal_alter('og_sm_site_homepage', $path, $context);
    $paths[$site->nid] = $path;
  }

  return $paths[$site->nid];
}

/**
 * Set the breadcrumb for the given Site.
 *
 * @param object $site
 *   The site object to setthe breadcrumb for.
 * @param array $path
 *   Array of links to append to the breadcumb.
 */
function og_sm_set_breadcrumb($site, $path = array()) {
  $label = entity_label('node', $site);
  $breadcrumb = array(l(t('Home'), '<front>'));
  // We don't want to add the site homepage to the breadcrumb when we are
  // currently on the site homepage or if the homepage is already included in
  // the path array. This is possible when an alternative homepage is set using
  // hook_og_sm_site_homepage_alter().
  $homepage = og_sm_site_homepage($site);
  $homepage_link = l($label, $homepage);
  if (!in_array($homepage_link, $path) && current_path() !== $homepage) {
    $breadcrumb[] = $homepage_link;
  }
  $breadcrumb = array_merge($breadcrumb, $path);
  drupal_set_breadcrumb($breadcrumb);
}

/**
 * Get a list of content types that can be used to create Site content.
 *
 * @return array
 *   Content types that are OG types, sorted by their name.
 */
function og_sm_content_get_types() {
  global $language;
  $langcode = $language->language;

  $types = &drupal_static(__FUNCTION__, array());

  if (empty($types[$langcode])) {
    $types[$langcode] = array();
    $content_types = node_type_get_types();

    $sort = array();
    $items = array();
    foreach ($content_types as $content_type) {
      if (!og_is_group_content_type('node', $content_type->type)) {
        continue;
      }

      $sort[$content_type->name] = $content_type->type;
      $items[$content_type->type] = $content_type;
    }

    // Sort the items.
    ksort($sort);
    foreach ($sort as $key) {
      $types[$langcode][$key] = $items[$key];
    }
  }

  return $types[$langcode];
}

/**
 * Check if a given content type is a Site content type.
 *
 * @param string $content_type_name
 *   The content type name to check.
 *
 * @return bool
 *   Is Site content type.
 */
function og_sm_content_is_site_content_type($content_type_name) {
  $types = og_sm_content_get_types();
  return array_key_exists($content_type_name, $types);
}

/**
 * Get all the Sites a node belongs to.
 *
 * @param object $node
 *   The site content.
 *
 * @return array
 *   All Site nodes keyed by their nid.
 */
function og_sm_content_get_sites($node) {
  $groups = og_get_entity_groups('node', $node);
  return _og_sm_filter_sites_from_groups($groups);
}

/**
 * Get the Site object the Site content node belongs to.
 *
 * If a content node belongs to multiple Sites, only the first will be returned.
 *
 * @param object $node
 *   The site content.
 *
 * @return object|false
 *   The site node (if any).
 */
function og_sm_content_get_site($node) {
  $sites = og_sm_content_get_sites($node);
  if (empty($sites)) {
    return FALSE;
  }

  return reset($sites);
}

/**
 * Check if a given node is content within a Site.
 *
 * @param object $node
 *   The node to check.
 *
 * @return bool
 *   Is Site content.
 */
function og_sm_content_is_site_content($node) {
  return (bool) og_sm_content_get_site($node);
}

/**
 * Check if a given node is member of the given Site.
 *
 * @param object $node
 *   The node to check.
 * @param object $site
 *   The site node.
 *
 * @return bool
 *   Is Site member.
 */
function og_sm_content_is_site_member($node, $site) {
  $sites = og_sm_content_get_sites($node);
  return !empty($sites[$site->nid]);
}

/**
 * Get all the sites a User belongs to.
 *
 * @param object $account
 *   The user object.
 *
 * @return array
 *   All Site nodes keyed by their nid.
 */
function og_sm_user_get_sites($account) {
  $groups = og_get_entity_groups('user', $account);
  return _og_sm_filter_sites_from_groups($groups);
}

/**
 * Get all the sites a User can manage.
 *
 * @param object|NULL $account
 *   (optional) The user object.
 *
 * @return array
 *   All Site nodes keyed by their nid.
 */
function og_sm_user_get_manageable_sites($account = NULL) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  // We use a query here as this is the fastest way to get the Sites the user
  // has access to.
  $q = db_select('node', 'n');
  $q->addField('n', 'nid');
  $q->condition('n.type', og_sm_get_site_types());
  $q->addTag('node_access');

  // Limit to the Sites the user can manage.
  if (!user_access('administer nodes')) {
    $q->join('og_membership', 'ogm', 'n.nid = %alias.gid');
    $q->condition('ogm.entity_type', 'user')
      ->condition('ogm.group_type', 'node')
      ->condition('ogm.state', 1)
      ->condition('ogm.etid', $account->uid);

    $q->join('og_users_roles', 'ogur', 'ogm.etid = %alias.uid AND ogm.gid = %alias.gid');
    $q->condition('ogur.group_type', 'node');

    $q->join('og_role_permission', 'ogrp', 'ogur.rid = %alias.rid');
    $q->condition('ogrp.permission', array('administer group', 'administer site'));
  }

  $q->orderBy('n.title', 'ASC');

  // Check if we have results.
  $nids = array_unique($q->execute()->fetchCol(0));
  if (!$nids) {
    return array();
  }

  return node_load_multiple($nids);
}

/**
 * Check if a given account is member of the given Site.
 *
 * @param object $account
 *   The user object.
 * @param object $site
 *   The Site node object.
 *
 * @return bool
 *   Is site member.
 */
function og_sm_user_is_member_of_site($account, $site) {
  $sites = og_sm_user_get_sites($account);
  return !empty($sites[$site->nid]);
}

/**
 * Helper function to get a list of Site objects from a list of group id's.
 *
 * @param array $groups
 *   Group info as returned by og_get_entity_groups().
 *
 * @return array
 *   All Site nodes keyed by their nid.
 */
function _og_sm_filter_sites_from_groups(array $groups) {
  $sites = array();
  if (empty($groups['node'])) {
    return $sites;
  }

  // Filter out only Site groups.
  $sites = array();
  foreach ($groups['node'] as $site_nid) {
    $site = og_sm_site_load($site_nid);
    if (!$site) {
      continue;
    }

    $sites[$site->nid] = $site;
  }

  return $sites;
}

/**
 * Implements hook_node_type_delete().
 */
function og_sm_node_type_delete($info) {
  // Remove the content type from the list of Site types.
  og_sm_site_type_remove($info->type);
}

/**
 * Implements hook_node_view().
 */
function og_sm_node_view($node, $view_mode, $langcode) {
  // Only for Site node types.
  if (!og_sm_is_site($node)) {
    return;
  }

  module_invoke_all('og_sm_site_view', $node, $view_mode, $langcode);
}

/**
 * Implements hook_node_presave().
 */
function og_sm_node_presave($node) {
  og_sm_hook_site('presave', $node);
}

/**
 * Implements hook_node_prepare().
 */
function og_sm_node_prepare($node) {
  og_sm_hook_site('prepare', $node);
}

/**
 * Implements hook_node_insert().
 */
function og_sm_node_insert($node) {
  og_sm_hook_site('insert', $node);
}

/**
 * Implements hook_node_update().
 */
function og_sm_node_update($node) {
  og_sm_hook_site('update', $node);
  if (_og_sm_node_update_alias_will_change($node)) {
    og_sm_hook_site('update_alias', $node);
  }
}

/**
 * Helper do identify if the node alias of a Site will change due to update.
 *
 * @param object $node
 *   The node being updated.
 *
 * @return bool
 *   The alias will be changed.
 */
function _og_sm_node_update_alias_will_change($node) {
  $pathauto_new = (!empty($node->path['pathauto']));
  $pathauto_old = (!empty($node->original->path['pathauto']));

  // Auto alias.
  if ($pathauto_new && $pathauto_old) {
    return ($node->title !== $node->original->title);
  }

  // Manual alias.
  if (!$pathauto_new && !$pathauto_old) {
    $alias_new = (!empty($node->path['alias']))
      ? $node->path['alias']
      : NULL;
    $alias_old = (!empty($node->path['original']['alias']))
      ? $node->path['original']['alias']
      : NULL;

    return ($alias_new !== $alias_old);
  }

  // Switching between auto & manual.
  return TRUE;
}

/**
 * Implements hook_node_delete().
 */
function og_sm_node_delete($node) {
  og_sm_hook_site('delete', $node);
}

/**
 * Trigger a hook_og_sm_site_ACTION for Site changes.
 *
 * This is used to let other modules know that an action was performed on a
 * node that is a Site type. This reduces the code module maintainers need to
 * write to detect if something changed on a Site node type.
 *
 * @param string $action
 *   Action that is triggered.
 * @param object $node
 *   The node for who to trigger the hook.
 */
function og_sm_hook_site($action, $node) {
  // Only for Site node types.
  if (!og_sm_is_site($node)) {
    return;
  }

  $hook = 'og_sm_site_' . $action;
  module_invoke_all($hook, $node);

  // Call the save hook for insert/update operations.
  $actions = array('insert', 'update');
  if (in_array($action, $actions)) {
    og_sm_hook_site('save', $node);
  }

  // Register shutdown functions for post_op operations.
  $post_actions = array('insert', 'update', 'save', 'delete');
  if (in_array($action, $post_actions)) {
    drupal_register_shutdown_function(
      'og_sm_hook_site',
      'post_' . $action,
      $node
    );
  }
}

/**
 * Helper to get the Site Alias by its nid.
 *
 * @param int $site_nid
 *   The Site NID.
 * @param string $language
 *   The language to get the alias for.
 *
 * @return string
 *   The Site alias.
 */
function _og_sm_site_alias_by_nid($site_nid, $language) {
  $source = 'node/' . $site_nid;
  $alias = db_select('url_alias', 'ur')
    ->fields('ur', array('alias'))
    ->condition('ur.source', $source)
    ->condition('ur.language', $language)
    ->execute()
    ->fetchField();

  return (!empty($alias)) ? $alias : $source;
}

/**
 * Helper to get the Site NID by its alias.
 *
 * @param string $alias
 *   The Site alias.
 * @param string $language
 *   The language to search for.
 *
 * @return int|false
 *   The Site id.
 */
function _og_sm_site_nid_by_alias($alias, $language) {
  $source = db_select('url_alias', 'ur')
    ->fields('ur', array('source'))
    ->condition('ur.alias', $alias)
    ->condition('ur.language', $language)
    ->execute()
    ->fetchField();

  if (empty($source)) {
    FALSE;
  }

  if (!preg_match('#^node/([0-9]+)$#', $source, $parts)) {
    return FALSE;
  }

  return (int) $parts[1];
}
