<?php
/**
 * @file
 * Site comment creation and administration functionality.
 */

/**
 * Permissions.
 */
define('OG_SM_COMMENT_OG_PERM_DELETE_ALL_COMMENTS', 'delete all comments');
define('OG_SM_COMMENT_OG_PERM_DELETE_OWN_COMMENTS', 'delete own comments');
define('OG_SM_COMMENT_OG_PERM_EDIT_ALL_COMMENTS', 'edit all comments');
define('OG_SM_COMMENT_OG_PERM_EDIT_OWN_COMMENTS', 'edit own comments');
define('OG_SM_COMMENT_OG_PERM_ADMINISTER_COMMENTS', 'administer comments');

/**
 * Comments for this node are open for anonymous users.
 */
define('OG_SM_COMMENT_NODE_OPEN_FOR_ANONYMOUS', '3');

/**
 * Implements hook_menu().
 */
function og_sm_comment_menu() {
  $items['group/%/%og_sm_site/admin/comments'] = array(
    'title' => 'Administer comments',
    'page callback' => 'og_sm_comment_admin_overview',
    'page arguments' => array(2),
    'access callback' => 'og_sm_site_permission_access',
    'access arguments' => array(2, OG_SM_COMMENT_OG_PERM_ADMINISTER_COMMENTS),
    'weight' => 10,
    'file' => 'og_sm_comment.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function og_sm_comment_menu_alter(&$items) {
  $items['comment/%/delete']['access callback'] = 'og_sm_comment_access';
  $items['comment/%/delete']['access arguments'] = array('delete', 1);
  $items['comment/%comment/edit']['access callback'] = 'og_sm_comment_access';
}

/**
 * Implements hook_permission().
 */
function og_sm_comment_permission() {
  // Create custom permissions for deleting comments so we don't have to rely on
  // 'administer comments'.
  return array(
    OG_SM_COMMENT_OG_PERM_DELETE_OWN_COMMENTS => array(
      'title' => t('Delete own comments'),
      'description' => t('Allows the user to delete his/her own comments.'),
    ),
    OG_SM_COMMENT_OG_PERM_DELETE_ALL_COMMENTS => array(
      'title' => t('Delete all comments'),
      'description' => t('Allows the user to delete all comments.'),
    ),
    OG_SM_COMMENT_OG_PERM_EDIT_ALL_COMMENTS => array(
      'title' => t('Edit all comments'),
      'description' => t('Allows the user to edit all comments.'),
    ),
  );
}

/**
 * Implements hook_og_permission().
 */
function og_sm_comment_og_permission() {
  return array(
    OG_SM_COMMENT_OG_PERM_ADMINISTER_COMMENTS => array(
      'title' => t('Administer comments'),
      'description' => t('Administer all comments within a Site.'),
    ),
    OG_SM_COMMENT_OG_PERM_DELETE_OWN_COMMENTS => array(
      'title' => t('Delete own comments'),
      'description' => t('Allows the user to delete his/her own comments.'),
    ),
    OG_SM_COMMENT_OG_PERM_DELETE_ALL_COMMENTS => array(
      'title' => t('Delete all comments'),
      'description' => t('Allows the user to delete all comments.'),
    ),
    OG_SM_COMMENT_OG_PERM_EDIT_ALL_COMMENTS => array(
      'title' => t('Edit all comments'),
      'description' => t('Allows the user to edit all comments.'),
    ),
    OG_SM_COMMENT_OG_PERM_EDIT_OWN_COMMENTS => array(
      'title' => t('Edit own comments'),
      'description' => t('Allows the user to edit his/her own comments.'),
    ),
  );
}

/**
 * Implements hook_module_implements_alter().
 */
function og_sm_comment_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['og_sm_comment'];
    unset($implementations['og_sm_comment']);
    $implementations['og_sm_comment'] = $group;
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * @see og_sm_comment_module_implements_alter()
 */
function og_sm_comment_entity_info_alter(&$entity_info) {
  $entity_info['comment']['access callback'] = 'og_sm_comment_access';
}

/**
 * Determines whether the current user has access to a particular comment.
 *
 * @param string $op
 *   The operation that is to be performed on the comment.
 * @param object $comment
 *   The comment object or id.
 * @param object $account
 *   (optional) The user account.
 *
 * @return bool
 *   TRUE if the current user has access to the comment, FALSE otherwise.
 */
function og_sm_comment_access($op, $comment, $account = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }

  // Since comment paths don't always use placeholders it's possible that
  // $comment is an id.
  if (!is_object($comment)) {
    $comment = comment_load($comment);
  }
  if (!$comment) {
    return FALSE;
  }

  // Comment administrators are allowed to perform all operations on all
  // comments.
  if (user_access('administer comments', $account)) {
    return TRUE;
  }

  // When determining access to a comment, 'comment_access' does not take any
  // access restrictions to the comment's associated node into account. If a
  // comment has an associated node, the user must be able to view it in order
  // to access the comment.
  if (isset($comment->nid)) {
    if (!node_access('view', node_load($comment->nid), $account)) {
      return FALSE;
    }
  }

  switch ($op) {
    case 'view':
      return user_access('access comments', $account);

    case 'delete':

      if (user_access(OG_SM_COMMENT_OG_PERM_DELETE_ALL_COMMENTS, $account)) {
        return TRUE;
      }
      $site = og_sm_comment_get_site($comment);
      if ($site && og_sm_site_nid_permission_access($site->nid, OG_SM_COMMENT_OG_PERM_DELETE_ALL_COMMENTS, $account)) {
        return TRUE;
      }
      if ($account->uid !== $comment->uid) {
        return FALSE;
      }
      if ((int) $comment->status !== COMMENT_PUBLISHED) {
        return FALSE;
      }
      if (user_access(OG_SM_COMMENT_OG_PERM_DELETE_OWN_COMMENTS, $account)) {
        return TRUE;
      }
      if ($site && og_sm_site_nid_permission_access($site->nid, OG_SM_COMMENT_OG_PERM_DELETE_OWN_COMMENTS, $account)) {
        return TRUE;
      }
      return FALSE;

    case 'update':
    case 'edit':
      if (user_access(OG_SM_COMMENT_OG_PERM_EDIT_ALL_COMMENTS, $account)) {
        return TRUE;
      }
      $site = og_sm_comment_get_site($comment);
      if ($site && og_sm_site_nid_permission_access($site->nid, OG_SM_COMMENT_OG_PERM_EDIT_ALL_COMMENTS, $account)) {
        return TRUE;
      }
      if ($account->uid !== $comment->uid) {
        return FALSE;
      }
      if ((int) $comment->status !== COMMENT_PUBLISHED) {
        return FALSE;
      }
      if (user_access(OG_SM_COMMENT_OG_PERM_EDIT_OWN_COMMENTS, $account)) {
        return TRUE;
      }
      if ($site && og_sm_site_nid_permission_access($site->nid, OG_SM_COMMENT_OG_PERM_EDIT_OWN_COMMENTS, $account)) {
        return TRUE;
      }
      return FALSE;
  }

  return FALSE;
}

/**
 * Determines whether a user has access to create a comment.
 *
 * @param object $node
 *   The node on which the comment should be made.
 * @param object|NULL $account
 *   (optional) The user account.
 *
 * @return bool
 *   TRUE if the user has access to create a comment, FALSE otherwise.
 */
function og_sm_comment_create_access($node, $account = NULL) {
  $site = og_sm_content_get_site($node);
  if (!$site) {
    return FALSE;
  }
  $content_type = og_sm_content_get_type_info_by_site($site, $node->type);
  if (!$content_type) {
    return FALSE;
  }
  if ($node->comment < COMMENT_NODE_OPEN || $content_type->comment < COMMENT_NODE_OPEN) {
    return FALSE;
  }
  if (!isset($account)) {
    global $user;
    $account = $user;
  }
  if ($account->uid === 0) {
    return (user_access('post comments', $account) && $content_type->comment === OG_SM_COMMENT_NODE_OPEN_FOR_ANONYMOUS);
  }

  return user_access('post comments', $account);
}

/**
 * Implements hook_comment_insert().
 */
function og_sm_comment_comment_insert($comment) {
  if (module_exists('og_sm_path')) {
    // Automatically create an alias for new comments.
    og_sm_comment_pathauto_update_alias($comment, 'insert');
  }
}

/**
 * Implements hook_views_api().
 */
function og_sm_comment_views_api() {
  return array("api" => "3.0");
}

/**
 * Implements hook_og_context_negotiation_info().
 */
function og_sm_comment_og_context_negotiation_info() {
  $providers = array();

  $providers['og_sm_context_comment'] = array(
    'name' => t('Site Comment'),
    'description' => t('Determine Site context based on the fact that we are on a comment made on Site page or a Site content page.'),
    'callback' => 'og_sm_comment_context_handler_comment',
  );

  return $providers;
}

/**
 * Tries to get the context based on the comment.
 *
 * The site context is determined base on the fact that we are on a comment
 * which has been made on a Site page or a Site content page.
 *
 * @return array|NULL
 *   Contexts grouped by the entity type.
 *
 * @see og_sm_context_og_context_negotiation_info
 */
function og_sm_comment_context_handler_comment() {
  // Get the content nid from the path.
  $path = current_path();
  preg_match('#^comment/(reply/)?([0-9]+)#', $path, $parts);
  if (empty($parts[2])) {
    return NULL;
  }

  switch ($parts[1]) {
    case 'reply/':
      $node = node_load($parts[2]);
      if (!$node) {
        return;
      }
      $site = og_sm_content_get_site($node);
      break;

    default:
      $comment = comment_load($parts[2]);
      if (!$comment) {
        return NULL;
      }
      $site = og_sm_comment_get_site($comment);
      break;
  }

  if ($site) {
    return array('node' => array((int) $site->nid));
  }

  return NULL;
}

/**
 * Get the Site object the Site comment belongs to.
 *
 * @param object $comment
 *   The comment object.
 *
 * @return object|NULL
 *   The site node (if any).
 */
function og_sm_comment_get_site($comment) {
  $node = node_load($comment->nid);
  if (!$node) {
    return FALSE;
  }

  // Is the node a Site?
  if (og_sm_is_site($node)) {
    return $node;
  }

  // Is the node Site Content?
  return og_sm_content_get_site($node);
}

/**
 * Update the URL aliases for multiple comments.
 *
 * @param array $comment_ids
 *   An array of comment IDs.
 * @param string $op
 *   Operation being performed on the comments ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function og_sm_comment_pathauto_update_alias_multiple(array $comment_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $comments = comment_load_multiple($comment_ids);
  foreach ($comments as $comment) {
    og_sm_comment_pathauto_update_alias($comment, $op, $options);
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($comment_ids), 'Updated URL alias for 1 comment.', 'Updated URL aliases for @count comments.'));
  }
}

/**
 * Update the URL aliases for an individual comment.
 *
 * @param object $comment
 *   A comment object.
 * @param string $op
 *   Operation being performed on the comment ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function og_sm_comment_pathauto_update_alias(stdClass $comment, $op, array $options = array()) {
  $options += array('language' => pathauto_entity_language('comment', $comment));

  // Skip processing if the comment has no pattern.
  if (!pathauto_pattern_load_by_entity('comment', '', $options['language'])) {
    return;
  }

  module_load_include('inc', 'pathauto');
  $uri = entity_uri('comment', $comment);
  pathauto_create_alias('comment', $op, $uri['path'], array('comment' => $comment), NULL, $options['language']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds the comment settings to the content type form ONLY if the comments are
 * set to OPEN on global level.
 */
function og_sm_comment_form_og_sm_content_admin_overview_type_edit_form_alter(&$form, &$form_state) {
  // Existing info.
  $info = og_sm_content_get_type_info_by_site($form['#site'], $form['#content_type']);

  // Add the comment settings only if comments are enabled for this content
  // type.
  if ((int) variable_get('comment_' . $info->type, 0) !== COMMENT_NODE_OPEN) {
    return;
  }

  // Group the fields.
  $form['content_comments'] = array(
    '#type' => 'fieldset',
    '#title' => t('Comments'),
  );

  $key = 'og_sm_content_' . $info->type . '_comment';
  $description = t(
    'Select whether the comment form can be shown for @content_type_plural.',
    array('@content_type_plural' => drupal_strtolower($info->name_plural))
  );
  $help = array(
    t('Hidden: No comments are allowed, and past comments are hidden.'),
    t('Closed: No comments are allowed, but any past comments remain visible.'),
    t('Open for anonymous users: Any content of this type is open to new comments by anonymous and logged in users.'),
    t('Open: Any content of this type is open to new comments by logged in users.'),
  );
  $description .= '<ul><li>' . implode('</li><li>', $help) . '</li></ul>';

  $form['content_comments'][$key] = array(
    '#type' => 'select',
    '#title' => t('Comments'),
    '#description' => $description,
    '#default_value' => $info->comment,
    '#options' => array(
      COMMENT_NODE_OPEN => t('Open'),
      OG_SM_COMMENT_NODE_OPEN_FOR_ANONYMOUS => t('Open for anonymous users'),
      COMMENT_NODE_CLOSED => t('Closed'),
      COMMENT_NODE_HIDDEN => t('Hidden'),
    ),
  );
}

/**
 * Implements hook_node_view().
 *
 * Checks the Site specific vs global settings to validate if comments should be
 * listed and form should be shown.
 */
function og_sm_comment_node_view($node, $view_mode, $langcode) {
  // Only if the content item belongs to a Site.
  $site = og_sm_content_get_site($node);
  if (!$site) {
    return;
  }

  $content_type = og_sm_content_get_type_info_by_site($site, $node->type);

  // Alter the comment related links and forms if the Site config overrides the
  // Global configuration.
  if (!og_sm_comment_create_access($node)) {
    unset($node->content['comments']['comment_form']);
    unset($node->content['links']['comment']['#links']['comment-add']);

    if (!isset($node->content['links']['comment']['#links']['comment_forbidden'])) {
      $node->content['links']['comment']['#links']['comment_forbidden'] = array(
        'title' => theme('comment_post_forbidden', array('node' => $node)),
        'html' => TRUE,
      );
    }
  }

  // Remove comments completely if the Site settings don't want them.
  if ((int) $content_type->comment === COMMENT_NODE_HIDDEN) {
    unset($node->content['comments']);
  }
}
