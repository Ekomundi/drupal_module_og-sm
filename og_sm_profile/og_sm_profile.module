<?php
/**
 * @file
 * OG SM Profile.
 */

/**
 * Our own cache bin to store loaded profiles.
 */
define('OG_SM_PROFILE_CACHE_BIN', 'cache_og_sm_profile');

/**
 * Permissions.
 */
define('OG_SM_PROFILE_PERM_ACCESS_ALL_PROFILES', 'access group user profiles');

/**
 * Implements hook_hook_info().
 */
function og_sm_profile_hook_info() {
  $hooks = array(
    'og_sm_profile_view' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_view_alter' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_presave' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_insert' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_update' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_delete' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_load' => array(
      'group' => 'og_sm',
    ),
    'og_sm_profile_alter' => array(
      'group' => 'og_sm',
    ),
  );
  return $hooks;
}

/**
 * Implements hook_menu().
 */
function og_sm_profile_menu() {
  $items = array();

  $items['group/%/%og_sm_site/profile'] = array(
    'title callback' => 'og_sm_profile_page_title',
    'page callback' => 'og_sm_profile_page',
    'page arguments' => array(),
    'access callback' => 'og_sm_profile_page_access',
    'access arguments' => array('view'),
    'file' => 'og_sm_profile.pages.inc',
    'type' => MENU_CALLBACK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['group/%/%og_sm_site/profile/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  // Don't use node/x/x/edit, the path will trigger the theme setting that
  // enabled the admin theme.
  $items['group/%/%og_sm_site/profile/modify'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_sm_profile_edit_form'),
    'access callback' => 'og_sm_profile_page_access',
    'access arguments' => array('edit'),
    'file' => 'og_sm_profile.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['profile/%og_sm_profile'] = array(
    'title callback' => 'og_sm_profile_page_title',
    'title arguments' => array(1),
    'page callback' => 'og_sm_profile_page',
    'page arguments' => array(1),
    'access callback' => 'og_sm_profile_page_access',
    'access arguments' => array('view', 1),
    'file' => 'og_sm_profile.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['profile/%og_sm_profile/modify'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_sm_profile_edit_form', 1),
    'access callback' => 'og_sm_profile_page_access',
    'access arguments' => array('edit', 1),
    'file' => 'og_sm_profile.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function og_sm_profile_permission() {
  return array(
    OG_SM_PROFILE_PERM_ACCESS_ALL_PROFILES => array(
      'title' => t('Access Site user profiles'),
      'description' => t('Allows a user to view other users group profiles'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_og_context_negotiation_info().
 */
function og_sm_profile_og_context_negotiation_info() {
  $providers = array();

  $providers['og_sm_context_profile'] = array(
    'name' => t('Site User Profile'),
    'description' => t('Determine Site context based on the fact that we are on a user profile linked to a Site.'),
    'callback' => 'og_sm_profile_context_handler_profile',
  );

  return $providers;
}

/**
 * Tries to get the context based on the profile.
 *
 * The site context is determined based on the fact that we are on a profile
 * which is linked to a Site.
 *
 * @return array|NULL
 *   Contexts grouped by the entity type.
 *
 * @see og_sm_profile_og_context_negotiation_info
 */
function og_sm_profile_context_handler_profile() {
  $path = current_path();
  preg_match('#^profile/([0-9]+)#', $path, $parts);
  if (empty($parts[1])) {
    return NULL;
  }

  // Get the Membership.
  $profile = og_membership_load($parts[1]);
  if ($profile) {
    return array('node' => array((int) $profile->site_nid));
  }

  return NULL;
}

/**
 * Menu item title callback for the 'profile' path.
 */
function og_sm_profile_page_title($profile) {
  if (!is_object($profile)) {
    $profile = og_sm_profile_load_from_context();
  }
  if (!$profile) {
    return '';
  }
  $account = user_load($profile->uid);
  return format_username($account);
}

/**
 * Custom access check to see if we can see the profile page.
 *
 * @param string $op
 *   The access operation, "view", "edit" or "cancel".
 * @param object|NULL $profile
 *   (optional) The site profile object.
 *
 * @return bool
 *   Whether the user can access the page.
 */
function og_sm_profile_page_access($op, $profile = NULL) {
  global $user;
  // An anonymous use can never have his own profile page so a profile should
  // always be supplied.
  if ($user->uid === 0 && empty($profile)) {
    return FALSE;
  }
  if (!is_object($profile)) {
    $profile = og_sm_profile_load_from_context();
  }
  if (!$profile) {
    return FALSE;
  }

  $account = user_load($profile->uid);

  switch ($op) {
    case 'view':
      if ($user->uid == $account->uid && $user->uid > 0) {
        return TRUE;
      }
      return user_access(OG_SM_PROFILE_PERM_ACCESS_ALL_PROFILES);

    case 'edit':
      return user_edit_access($account);

    case 'cancel':
      return user_cancel_access($account);
  }

  return FALSE;
}

/**
 * Clear all profiles from cache for a user.
 *
 * @param int $uid
 *   User uid for which to purge the cached profiles.
 */
function _og_sm_profile_clear_profile_cache($uid = NULL) {
  if (!$uid) {
    cache_clear_all(NULL, OG_SM_PROFILE_CACHE_BIN);
  }
  else {
    cache_clear_all($uid . ':', OG_SM_PROFILE_CACHE_BIN, TRUE);
  }
}

/**
 * Create a site user profile.
 *
 * @param int $site_nid
 *   The site nid.
 * @param int $uid
 *   The user id of the user.
 *
 * @return object
 *   The profile object.
 *
 * @throws \Exception
 * @throws \InvalidMergeQueryException
 */
function og_sm_profile_create($site_nid, $uid) {

  $profile = array(
    'site_nid' => $site_nid,
    'uid' => $uid,
    'created' => REQUEST_TIME,
  );

  module_invoke_all('og_sm_profile_presave', $profile);

  $return = db_merge('og_sm_profile')
    ->key(array('site_nid' => $site_nid, 'uid' => $uid))
    ->fields($profile)
    ->execute();

  $profile = (object) $profile;
  if ($return == SAVED_NEW) {
    // Get profile id.
    $profile->id = db_select('og_sm_profile')
      ->fields('og_sm_profile', array('id'))
      ->condition('site_nid', $site_nid)
      ->condition('uid', $uid)
      ->execute()->fetchField();
    module_invoke_all('og_sm_profile_insert', $profile);
  }
  else {
    module_invoke_all('og_sm_profile_update', $profile);
  }
  return $profile;
}

/**
 * Deletes a profile.
 *
 * @param int $uid
 *   The user id of the user.
 * @param string|NULL $site_nid
 *   (optional) The machine name of the group.
 */
function og_sm_profile_delete($uid, $site_nid = NULL) {
  $query = db_delete('og_sm_profile')
    ->condition('uid', $uid);
  if ($site_nid) {
    $query->condition('site_nid', $site_nid);
  }
  $query->execute();

  module_invoke_all('og_sm_profile_delete', $uid, $site_nid);

  _og_sm_profile_clear_profile_cache($uid);
}

/**
 * Implements hook_user_delete().
 */
function og_sm_profile_user_delete($account) {
  og_sm_profile_delete($account->uid);
}

/**
 * Returns the profile of the user from the OG context.
 *
 * @param int $uid
 *   The uid of the profile to load.
 * @param bool $autocreate
 *   Should profiles be created when they don't exist?
 *
 * @return object|NULL
 *   The site user profile.
 */
function og_sm_profile_load_from_context($uid = NULL, $autocreate = TRUE) {
  // If no uid supplied, use the global user.
  if (!$uid) {
    $uid = $GLOBALS['user']->uid;
    // Skip the anonymous user.
    if (!$uid) {
      return NULL;
    }
  }

  $site = og_sm_current_site();
  if (!$site) {
    return;
  }

  // To keep this lightweight, we can choose not to create a profile.
  if ($autocreate) {
    return og_sm_profile_get_or_create($site->nid, $uid);
  }
  return og_sm_profile_load_by_uid($site->nid, $uid);
}

/**
 * Retrieves a site user profile.
 *
 * This function will always return a profile for a site user. If a user has no
 * profile yet, one will be created.
 *
 * @param int $site_nid
 *   The site node id.
 * @param int $uid
 *   The user id of the user.
 *
 * @return object
 *   The site user profile.
 */
function og_sm_profile_get_or_create($site_nid, $uid) {
  $profile = og_sm_profile_load_by_uid($site_nid, $uid);
  if (!isset($profile->id)) {
    $new_profile = og_sm_profile_create($site_nid, $uid);
    // Merge in the defaults for new profiles.
    $profile = (object) array_merge((array) $profile, (array) $new_profile);
  }
  return $profile;
}

/**
 * Returns a fully loaded site user profile.
 *
 * @param int $profile_id
 *   The site user profile id.
 * @param bool $reset
 *   (optional) Skip loading from caches, defaults to FALSE.
 *
 * @return mixed
 *   The loaded profile of a user within a site.
 */
function og_sm_profile_load($profile_id, $reset = TRUE) {
  $profiles = og_sm_profile_load_multiple(array($profile_id), $reset);
  return $profiles ? reset($profiles) : FALSE;
}

/**
 * Returns an array of fully loaded site user profiles.
 *
 * @param array $profile_ids
 *   An array of profile ids.
 * @param bool $reset
 *   (optional) Skip loading from caches, defaults to FALSE.
 *
 * @return array
 *   The array of loaded profiles user objects within a site.
 */
function og_sm_profile_load_multiple($profile_ids, $reset = FALSE) {
  $profiles_data = db_select('og_sm_profile', 'gp')
    ->fields('gp')
    ->condition('id', $profile_ids)
    ->execute()
    ->fetchAllAssoc('id');

  if (!$profiles_data) {
    return array();
  }
  $profiles = array();
  foreach ($profiles_data as $profile_data) {
    $profiles[] = og_sm_profile_load_by_uid($profile_data->site_nid, $profile_data->uid, $reset);
  }
  return $profiles;
}

/**
 * Returns a fully loaded site user profile based on a user id and site id.
 *
 * @param int $site_nid
 *   The site node id.
 * @param int $uid
 *   The user id of the user.
 * @param bool $reset
 *   (optional) Skip loading from caches, defaults to FALSE.
 *
 * @return mixed
 *   The loaded profile a user within a site.
 */
function og_sm_profile_load_by_uid($site_nid, $uid, $reset = FALSE) {

  $query = new EntityFieldQuery();

  $query->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('entity_type', 'user')
    ->propertyCondition('gid', $site_nid)
    ->propertyCondition('etid', $uid);

  $result = $query->execute();

  if (isset($result['og_membership'])) {
    $id = reset($result['og_membership']);
    return og_membership_load($id);
  }

  $empty_membership = (object) array(
    'gid' => $site_nid,
    'etid' => $uid,
  );
  return $empty_membership;

  $cid = $uid . ':' . $site_nid;
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['profiles'] = &drupal_static(__FUNCTION__);
  }
  $profiles = &$drupal_static_fast['profiles'];
  if (!isset($profiles[$cid]) || $reset) {
    if (!$reset && $cache = cache_get($cid, OG_SM_PROFILE_CACHE_BIN)) {
      $profile = $cache->data;
    }
    else {
      $profile = db_select('og_sm_profile', 'gp')
        ->fields('gp')
        ->condition('site_nid', $site_nid)
        ->condition('uid', $uid)
        ->execute()
        ->fetchObject();

      // Allow other modules to alter a profile.
      $empty_profile = (object) array(
        'site_nid' => $site_nid,
        'uid' => $uid,
        'created' => REQUEST_TIME,
      );
      $profile = is_object($profile) ? $profile : $empty_profile;
      drupal_alter('og_sm_profile', $profile);

      if (isset($profile->id)) {
        cache_set($cid, $profile, OG_SM_PROFILE_CACHE_BIN);
      }
    }
    $profiles[$cid] = $profile;
  }
  // Allow other modules to react on profile load.
  module_invoke_all('og_sm_profile_load', $profiles[$cid]);

  return $profiles[$cid];
}

/**
 * Implements hook_flush_caches().
 */
function og_sm_profile_flush_caches() {
  return array(OG_SM_PROFILE_CACHE_BIN);
}

/**
 * Implements hook_theme().
 */
function og_sm_profile_theme() {
  return array(
    'og_sm_profile_page' => array(
      'template' => 'templates/og_sm_profile_page',
      'variables' => array(
        'sections' => array(),
        'profile' => NULL,
      ),
    ),
    'og_sm_profile_page_section' => array(
      'variables' => array(
        'label' => NULL,
        'elements' => NULL,
      ),
      'file' => 'og_sm_profile.theme.inc',
    ),
  );
}

/**
 * Render callback for the basic info profile section.
 *
 * @param object $profile
 *   The site user profile.
 *
 * @return array
 *   Renderable array to build the section markup.
 */
function og_sm_profile_section_basic_info($profile) {
  $user = user_load($profile->uid);
  return array(
    '#theme' => 'og_sm_profile_page_section',
    '#label' => t('Profile'),
    '#elements' => array(
      'basic_info' => array(
        '#type' => 'html_tag',
        '#tag' => 'address',
        '#value' => $user->mail,
        '#label' => $user->name,
      ),
    ),
  );
}

/**
 * Implements hook_url_outbound_alter().
 */
function og_sm_profile_url_outbound_alter(&$path, &$options, $original_path) {
  // Rewrite all outgoing site admin paths for paths that do not have an alias.
  if (module_exists('og_sm_path') && preg_match('#^group/node/([0-9]+)(/profile.*)#', $path, $parts)) {
    $site = og_sm_site_load($parts[1]);
    if ($site) {
      $path = og_sm_path($site) . $parts[2];
    }
  }
}

/**
 * Implements hook_url_inbound_alter().
 */
function og_sm_profile_url_inbound_alter(&$path, $original_path, $path_language) {
  if (module_exists('og_sm_path') && preg_match('#^([\w/_-]+)(/profile.*)#', $path, $parts)) {
    $site = og_sm_path_load_site($parts[1]);
    if ($site) {
      $path = sprintf('group/node/%d%s', $site->nid, $parts[2]);
    }
  }
}

/**
 * Update the URL aliases for multiple profiles.
 *
 * @param array $profile_ids
 *   An array of profile IDs.
 * @param string $op
 *   Operation being performed on the profiles ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function og_sm_profile_pathauto_update_alias_multiple(array $profile_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $profiles = og_sm_profile_load_multiple($profile_ids);
  foreach ($profiles as $profile) {
    og_sm_profile_pathauto_update_alias($profile, $op, $options);
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($profile_ids), 'Updated URL alias for 1 profile.', 'Updated URL aliases for @count profiles.'));
  }
}

/**
 * Update the URL aliases for an individual profile.
 *
 * @param object $profile
 *   A profile object.
 * @param string $op
 *   Operation being performed on the profile ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function og_sm_profile_pathauto_update_alias($profile, $op, array $options = array()) {
  // Skip processing if the profile has no pattern.
  if (!pathauto_pattern_load_by_entity('og_sm_profile')) {
    return;
  }

  module_load_include('inc', 'pathauto');
  $path = 'profile/' . $profile->id;
  pathauto_create_alias('og_sm_profile', $op, $path, array('og_sm_profile' => $profile));
}
