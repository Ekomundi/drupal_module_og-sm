<?php
/**
 * @file
 * Tests for the og_sm_content module.
 */

/**
 * Tests about the OG SM Content functionality.
 */
class OgSmContentTestCase extends OgSmWebTestCase {
  /**
   * Test artifacts.
   */
  protected $userAdmin;
  protected $userDefault;

  protected $site;
  protected $siteType;

  protected $siteUserPageArticle;
  protected $siteUserArticle;

  protected $siteContentTypeNamePage = 'og_sm_site_content_type_page';
  protected $siteContentTypePage;
  protected $siteContentTypeNameArticle = 'og_sm_site_content_type_article';
  protected $siteContentTypeArticle;

  protected $permissionCreatePage = 'create og_sm_site_content_type_page content';
  protected $permissionCreateArticle = 'create og_sm_site_content_type_article content';

  protected $roleTypesPageArticle;
  protected $roleTypesArticle;

  /**
   * {@inheritdoc}
   */
  public static function getInfo() {
    return array(
      'name' => t('Site Content management'),
      'description' => t('Tests the Site Content management functionality.'),
      'group' => t('Organic Groups Site Manager'),
    );
  }

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    // Enable required modules.
    $modules = array('og_sm_content');
    parent::setUp($modules);
  }

  /**
   * Helper to setup the content items.
   */
  private function setUpContent() {
    // Create the site.
    $this->siteType = $this->ogSmCreateGroupNodeType();
    og_sm_site_type_add($this->siteType);
    $this->site = $this->ogSmCreateGroup($this->siteType);

    // Create site content types.
    $this->siteContentTypePage = node_type_load(
      $this->ogSmCreateGroupContentNodeType($this->siteContentTypeNamePage)
    );
    $this->siteContentTypeArticle = node_type_load(
      $this->ogSmCreateGroupContentNodeType($this->siteContentTypeNameArticle)
    );
  }

  /**
   * Helper to setup the users.
   */
  private function setUpUsers() {
    // Create site roles.
    $this->roleTypesPageArticle = og_role_create('role1', 'node', 0, $this->siteType);
    og_role_save($this->roleTypesPageArticle);
    $this->roleTypesArticle = og_role_create('role2', 'node', 0, $this->siteType);
    og_role_save($this->roleTypesArticle);

    // Grant permissions to the roles.
    og_role_grant_permissions(
      $this->roleTypesPageArticle->rid,
      array($this->permissionCreatePage, $this->permissionCreateArticle)
    );
    og_role_grant_permissions(
      $this->roleTypesArticle->rid,
      array($this->permissionCreateArticle)
    );

    // Create users.
    $this->userAdmin = $this->ogSmCreateAdminUser();
    $this->userDefault = $this->drupalCreateUser();
    $this->siteUserPageArticle = $this->ogSmCreateGroupUser(array(), array($this->site));
    $this->siteUserArticle = $this->ogSmCreateGroupUser(array(), array($this->site));

    // Grant permissions.
    og_role_grant('node', $this->site->nid, $this->siteUserPageArticle->uid, $this->roleTypesPageArticle->rid);
    og_role_grant('node', $this->site->nid, $this->siteUserArticle->uid, $this->roleTypesArticle->rid);
  }

  /**
   * Overwrites a content type basic info to be site specific.
   *
   * @param object $site
   *   The site node.
   * @param string $content_type
   *   The content type's machine name.
   * @param array $info
   *   A key value array with site specific info for the content type.
   */
  private function setupSiteSpecificContentType($site, $content_type, $info) {
    $variable_base = 'og_sm_content_' . $content_type . '_';
    foreach ($info as $name => $value) {
      og_sm_variable_set($site->nid, $variable_base . $name, $value);
    }
  }

  /**
   * Test the helper to create the content/add/type path.
   */
  public function testContentAddUri() {
    $site = new stdClass();
    $site->nid = 555;
    $type = 'test_type';

    $this->assertEqual(
      'group/node/555/content/add/test-type',
      og_sm_content_add_uri($site, $type)
    );
  }

  /**
   * Tests the helper to get all Site content types a user can create.
   */
  public function testGetTypesBySite() {
    // Setup test data.
    $this->setUpContent();
    $this->setUpUsers();

    // Test for default user.
    $this->assertEqual(array(), og_sm_content_get_types_by_site($this->site, $this->userDefault));

    $this->siteContentTypeArticle = og_sm_content_get_type_info_by_site($this->site, $this->siteContentTypeArticle);
    $this->siteContentTypePage = og_sm_content_get_type_info_by_site($this->site, $this->siteContentTypePage);
    // Test getting the types for an admin user.
    $expected = array(
      $this->siteContentTypeNameArticle => $this->siteContentTypeArticle,
      $this->siteContentTypeNamePage => $this->siteContentTypePage,
    );
    $this->assertEqual($expected, og_sm_content_get_types_by_site($this->site, $this->userAdmin));

    // Test for user 1.
    $this->assertEqual($expected, og_sm_content_get_types_by_site($this->site, $this->siteUserPageArticle));

    // Test for user 2.
    $expected = array(
      $this->siteContentTypeNameArticle => $this->siteContentTypeArticle,
    );
    $this->assertEqual($expected, og_sm_content_get_types_by_site($this->site, $this->siteUserArticle));
  }

  /**
   * Test the access callbacks.
   */
  public function testAccessCallbacks() {
    // Setup test data.
    $this->setUpContent();
    $this->setUpUsers();

    $path_overview = 'group/node/' . $this->site->nid . '/content/add';
    $path_add_page = $path_overview . '/' . preg_replace('/_/', '-', $this->siteContentTypeNamePage);
    $path_add_article = $path_overview . '/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);

    // Not logged in.
    $this->drupalGet($path_overview);
    $this->assertResponse(403, 'User is not allowed to view the node/add page.');
    $this->drupalGet($path_add_page);
    $this->assertResponse(403, 'User is not allowed to add Page content.');
    $this->drupalGet($path_add_article);
    $this->assertResponse(403, 'User is not allowed to add Article content.');

    // Default user.
    $this->verbose('Log in as Default user.');
    $this->drupalLogin($this->userDefault);
    $this->drupalGet($path_overview);
    $this->assertResponse(403, 'User is not allowed to view the node/add page.');
    $this->drupalGet($path_add_page);
    $this->assertResponse(403, 'User is not allowed to add Page content.');
    $this->drupalGet($path_add_article);
    $this->assertResponse(403, 'User is not allowed to add Article content.');

    // Admin user.
    $this->verbose('Log in as Admin user.');
    $this->drupalLogin($this->userAdmin);
    $this->drupalGet($path_overview);
    $this->assertResponse(200, 'User is allowed to view the node/add page.');
    $this->drupalGet($path_add_page);
    $this->assertResponse(200, 'User is allowed to add Page content.');
    $this->drupalGet($path_add_article);
    $this->assertResponse(200, 'User is allowed to add Article content.');

    // User with access to all content.
    $this->verbose('Log in as user who can create pages & articles.');
    $this->drupalLogin($this->siteUserPageArticle);
    $this->drupalGet($path_overview);
    $this->assertResponse(200, 'User is allowed to view the node/add page.');
    $this->drupalGet($path_add_page);
    $this->assertResponse(200, 'User is allowed to add Page content.');
    $this->drupalGet($path_add_article);
    $this->assertResponse(200, 'User is allowed to add Article content.');

    // User with access to only articles.
    $this->verbose('Log in as user who can create only articles.');
    $this->drupalLogin($this->siteUserArticle);
    $this->drupalGet($path_overview);
    $this->assertResponse(200, 'User is allowed to view the node/add page.');
    $this->drupalGet($path_add_page);
    $this->assertResponse(403, 'User is not allowed to add Page content.');
    $this->drupalGet($path_add_article);
    $this->assertResponse(200, 'User is allowed to add Article content.');
  }

  /**
   * Test the hook_url_outbound_alter() implementation.
   */
  public function testUrlOutboundAlter() {
    // Enable the og_sm_path module.
    module_enable(array('og_sm_path'), TRUE);

    // Setup test data.
    $this->setUpContent();
    $site_path = 'site-path-test';
    og_sm_path_set($this->site, $site_path, FALSE);

    $site_nid = $this->site->nid;
    $options = array();

    // Test rewriting for non Site paths.
    $path = $path_expected = 'group/node/987654321/content/add';
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);

    // Test rewriting admin path rewrite for a Site.
    $path = 'group/node/' . $site_nid . '/content/add/page';
    $path_expected = $site_path . '/content/add/page';
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);

    // Setup site specific content type info.
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'machine_name' => 'llama',
    ));

    // Verify that the add content path is now uses the site specific content
    // type alias.
    $path = 'group/node/' . $site_nid . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    $path_expected = $site_path . '/content/add/llama';
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);

    // Verify that the content type alias is not used for another site.
    $llama_site = $this->ogSmCreateGroup($this->siteType);
    $site_path = 'site-llamas';
    og_sm_path_set($llama_site, $site_path, FALSE);
    $path = 'group/node/' . $llama_site->nid . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    $path_expected = $site_path . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);

    // Unless we also set an alias to the article content type for that site.
    $this->setupSiteSpecificContentType($llama_site, $this->siteContentTypeNameArticle, array(
      'machine_name' => 'llama',
    ));
    $path_expected = $site_path . '/content/add/llama';
    $path = 'group/node/' . $llama_site->nid . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);

    // Verify that if the machine name has underscores in it, it is replaced
    // with dashes.
    $this->setupSiteSpecificContentType($llama_site, $this->siteContentTypeNameArticle, array(
      'machine_name' => 'llama_group',
    ));
    $path = 'group/node/' . $llama_site->nid . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    $path_expected = $site_path . '/content/add/llama-group';
    og_sm_content_url_outbound_alter($path, $options, 'foo/bar');
    $this->assertEqual($path_expected, $path);
  }

  /**
   * Test the hook_url_inbound_alter() implementation.
   */
  public function testUrlInboundAlter() {
    // Enable the og_sm_path module.
    module_enable(array('og_sm_path'), TRUE);

    // Setup test data.
    $this->setUpContent();
    $site_path = 'site-path-test';
    og_sm_path_set($this->site, $site_path, FALSE);

    // Not a Site path.
    $path = $path_expected = 'content/test/45687266/content/add/article';
    og_sm_content_url_inbound_alter($path, 'foo/bar', 'en');
    $this->assertEqual($path_expected, $path);

    // Site path.
    $path = $site_path . '/content/add';
    $path_expected = 'group/node/' . $this->site->nid . '/content/add';
    og_sm_content_url_inbound_alter($path, 'foo/bar', 'nl');
    $this->assertEqual($path_expected, $path);

    // Setup site specific content type info.
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'machine_name' => 'llama',
    ));

    // Verify that add content path finds the correct content type based on its
    // alias name.
    $path = $site_path . '/content/add/llama';
    $path_expected = 'group/node/' . $this->site->nid . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    og_sm_content_url_inbound_alter($path, 'foo/bar', 'nl');
    $this->assertEqual($path_expected, $path);

    // Set a site specific content type name with multiple words.
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'machine_name' => 'llama_group',
    ));
    // Verify that when the underscores are replaced with dashes the original
    // content type is still found.
    $path = $site_path . '/content/add/llama-group';
    og_sm_content_url_inbound_alter($path, 'foo/bar', 'nl');
    $this->assertEqual($path_expected, $path);
  }

  /**
   * Test the og_sm_content_add_content_access() callback.
   */
  public function testAddContentAccessCallback() {
    // Setup test data.
    $this->setUpContent();
    $this->setUpUsers();

    // Default user.
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNamePage, $this->userDefault);
    $this->assertFalse($access, 'Default user is not allowed to add Page content.');

    // Admin user.
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNamePage, $this->userAdmin);
    $this->assertTrue($access, 'Admin user is allowed to add Page content.');
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNameArticle, $this->userAdmin);
    $this->assertTrue($access, 'Admin user is allowed to add Article content.');

    // User with access to all content.
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNamePage, $this->siteUserPageArticle);
    $this->assertTrue($access, 'User 1 is allowed to add Page content.');
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNameArticle, $this->siteUserPageArticle);
    $this->assertTrue($access, 'User 1 is allowed to add Article content.');

    // User with access to only articles.
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNamePage, $this->siteUserArticle);
    $this->assertFalse($access, 'User 2 is not allowed to add Page content.');
    $access = og_sm_content_add_content_access($this->site, $this->siteContentTypeNameArticle, $this->siteUserArticle);
    $this->assertTrue($access, 'User 2 is allowed to add Article content.');
  }

  /**
   * Test setting site specific info for a content type.
   */
  public function testSiteSpecificContentType() {
    module_enable(array('og_sm_comment'));
    $this->resetAll();

    // Setup test data.
    $this->setUpContent();
    $this->setUpUsers();
    // Setup site specific content type info.
    $content_type_name = 'Llama';
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'name' => $content_type_name,
    ));

    // Login as admin user.
    $this->drupalLogin($this->userAdmin);

    // Check if then content type name on the node add page has been replaced.
    $base_path = 'group/node/' . $this->site->nid;
    $path_add_article = $base_path . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    $this->drupalGet($path_add_article);
    $this->assertResponse(200);
    $this->assertText(t('Create @name', array('@name' => $content_type_name)));

    // Check if then content type name on the node edit page has been replaced.
    $node = $this->ogSmCreateGroupContent($this->siteContentTypeNameArticle, array($this->site));
    $this->drupalGet('node/' . $node->nid . '/edit');
    $this->assertRaw(t('<em>Edit @type</em> @title', array(
      '@type' => $content_type_name,
      '@title' => $node->title,
    )));

    // Check if the comment form is rendered.
    $this->drupalGet('node/' . $node->nid);
    $this->assertText(t('Add new comment'));
    // Create comment.
    $comment_edit = array(
      'subject' => $this->randomName(),
      'comment_body[und][0][value]' => $this->randomName(),
    );
    $this->drupalPost(NULL, $comment_edit, t('Save'));
    $this->assertText($comment_edit['subject']);

    // Hide the comments via the site specific settings.
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'comment' => COMMENT_NODE_HIDDEN,
    ));
    // Verify that the comment form and previous comments are not rendered
    // anymore.
    $this->drupalGet('node/' . $node->nid);
    $this->assertNoText(t('Add new comment'));
    $this->assertNoText($comment_edit['subject']);

    // Close the comment form, this means existing comments are still shown but
    // the comment form itself is not displayed.
    $this->setupSiteSpecificContentType($this->site, $this->siteContentTypeNameArticle, array(
      'comment' => COMMENT_NODE_CLOSED,
    ));
    // Verify that the comment form is not shown anymore but the existing
    // comments are still there.
    $this->drupalGet('node/' . $node->nid);
    $this->assertNoText(t('Add new comment'));
    $this->assertText($comment_edit['subject']);

    // Verify that these changes have no effect on another site.
    $second_site = $this->ogSmCreateGroup($this->siteType);

    // Check if then content type name on the node add page has been replaced.
    $base_path = 'group/node/' . $second_site->nid;
    $path_add_article = $base_path . '/content/add/' . preg_replace('/_/', '-', $this->siteContentTypeNameArticle);
    $this->drupalGet($path_add_article);
    $this->assertResponse(200);
    $this->assertText(t('Create @name', array('@name' => $this->siteContentTypeNameArticle)));

    // Check if then content type name on the node edit page has been replaced.
    $node = $this->ogSmCreateGroupContent($this->siteContentTypeNameArticle, array($second_site));
    $this->drupalGet('node/' . $node->nid . '/edit');
    $this->assertRaw(t('<em>Edit @type</em> @title', array(
      '@type' => $this->siteContentTypeNameArticle,
      '@title' => $node->title,
    )));

    // Check if the comment form is rendered.
    $this->drupalGet('node/' . $node->nid);
    $this->assertText(t('Add new comment'));
  }

  /**
   * Test getting the Site specific content type settings.
   */
  public function testGetTypeInfoBySite() {
    module_enable(array('comment'));
    $this->resetAll();
    $this->setUpContent();

    // Content type outside Sites.
    $noSiteContentType = $this->drupalCreateContentType();
    $this->assertFalse(
      og_sm_content_get_type_info_by_site(
        $this->site,
        $noSiteContentType->type
      ),
      'No info available for content types that are not availabe as Site content.'
    );

    // Default configuration = Platform values.
    $type_article = clone $this->siteContentTypeArticle;
    $article_info = og_sm_content_get_type_info_by_site($this->site, $type_article);
    $this->assertEqual(
      $this->siteContentTypeArticle->type,
      $article_info->site_type,
      'Default site_type = global content type Machine name.'
    );
    $this->assertEqual(
      $this->siteContentTypeArticle->name,
      $article_info->name,
      'Default name = global content type Name.'
    );
    $this->assertEqual(
      $this->siteContentTypeArticle->name,
      $article_info->name_plural,
      'Default name_plural = global content type Name.'
    );
    $this->assertEqual(
      $this->siteContentTypeArticle->name,
      $article_info->name_plural,
      'Default name_plural = global content type Name.'
    );

    // Load info by type name.
    $article_info_by_name = og_sm_content_get_type_info_by_site(
      $this->site,
      $type_article->type
    );
    $this->assertEqual(
      $article_info,
      $article_info_by_name,
      'Function loads the type if the name is given instead of the object.'
    );

    // Set the comment default to open.
    variable_set('comment_' . $type_article->type, COMMENT_NODE_OPEN);
    $this->assertEqual(
      variable_get('comment_' . $type_article->type, COMMENT_NODE_OPEN),
      $type_article->comment,
      'Comments get by default the same config as Global.'
    );

    // Site configuration overrides the configuration.
    $key_base = 'og_sm_content_' . $this->siteContentTypeNameArticle . '_';
    og_sm_variable_set($this->site->nid, $key_base . 'machine_name', 'machine_name_test');
    og_sm_variable_set($this->site->nid, $key_base . 'name', 'name_test');
    og_sm_variable_set($this->site->nid, $key_base . 'name_plural', 'name_plural_test');
    og_sm_variable_set($this->site->nid, $key_base . 'comment', COMMENT_NODE_CLOSED);

    $type_article = clone $this->siteContentTypeArticle;
    $article_info = og_sm_content_get_type_info_by_site($this->site, $type_article);

    $this->assertEqual(
      'machine_name_test',
      $article_info->site_type,
      'Machine name (type) is overridden by Site config.'
    );
    $this->assertEqual(
      'name_test',
      $article_info->name,
      'Human name (name) is overridden by Site config.'
    );
    $this->assertEqual(
      'name_plural_test',
      $article_info->name_plural,
      'Human name plural (name_plural) is overridden by Site config.'
    );
    $this->assertEqual(
      COMMENT_NODE_CLOSED,
      $article_info->comment,
      'Comment settings (comment) is overridden by Site config.'
    );

    // Global comment configuration restricts Site configuration.
    variable_set('comment_' . $type_article->type, COMMENT_NODE_HIDDEN);
    og_sm_variable_set($this->site->nid, $key_base . 'comment', COMMENT_NODE_OPEN);

    $type_article = clone $this->siteContentTypeArticle;
    $article_info = og_sm_content_get_type_info_by_site($this->site, $type_article);
    $this->assertEqual(
      COMMENT_NODE_HIDDEN,
      $article_info->comment,
      'Site Comment settings is overruled by stricter global config (hidden).'
    );

    variable_set('comment_' . $type_article->type, COMMENT_NODE_CLOSED);
    $type_article = clone $this->siteContentTypeArticle;
    $article_info = og_sm_content_get_type_info_by_site($this->site, $type_article);
    $this->assertEqual(
      COMMENT_NODE_CLOSED,
      $article_info->comment,
      'Site Comment settings is overruled by stricter global config (closed).'
    );
  }

}
